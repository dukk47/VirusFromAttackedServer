import shodan
import threading
import queue
import os
import re
import time
import socket
import sys
import datetime
from colorama import init, Fore, Style

SHODAN_API_KEY = "YOUR_SHODAN_API_KEY"  # <-- Put your Shodan API key here

init(autoreset=True)
LIME = Fore.LIGHTGREEN_EX

banner = f"""{LIME}{Style.BRIGHT}
╔════════════════════════════════════════════════════════╗
║                                                        ║
║              Vite Grabber By Bob Marley                ║
║                                                        ║
╚════════════════════════════════════════════════════════╝
{Style.RESET_ALL}"""
print(banner)

VITE_QUERIES = [
    'http.title:"VITE"',
    'http.title:"VITE + VUE"',
    'http.title:"VITE + REACT"',
    'http.title:"VITE + SVELTE"',
    'http.title:"VITE + ANGULAR"',
    'http.title:"VITE + Preact"',
    'http.title:"VITE + Solid"',
    'http.title:"VITE + Lit"',
    'http.title:"VITE + SvelteKit"',
    'http.title:"VITE + Astro"',
    'http.headers.server:"vite"',
    'port:5173',
    'port:3000',
    'port:4173',
    'port:5000',
    'port:8080',
    'http.favicon.hash:-2062596654',  # Vite default favicon hash
    'http.html:"Vite"',
    'http.html:"Vite HMR"',
    'http.html:"vite.svg"',
    'http.html:"@vite/client"',
    'http.html:"vite:load"',
    'http.html:"vite:css"',
    'http.html:"vite:import"',
    'http.html:"vite:dev"',
    'http.html:"vite:server"',
    'http.html:"vite:hmr"',
    'http.html:"vite:env"',
    'http.html:"vite:config"',
    'http.html:"vite:plugin"',
    'http.html:"vite:resolve"',
    'http.html:"vite:build"',
    'http.html:"vite:optimize"',
    'http.html:"vite:worker"',
    'http.html:"vite:manifest"',
    'http.html:"vite:assets"',
    'http.html:"vite:base"',
    'http.html:"vite:alias"',
    'http.html:"vite:define"',
    'http.html:"vite:esbuild"',
    'http.html:"vite:rollup"',
    'http.html:"vite:preload"',
    'http.html:"vite:prebundle"',
    'http.html:"vite:transform"',
    'http.html:"vite:cache"',
    'http.html:"vite:logger"',
    'http.html:"vite:dep"',
    'http.html:"vite:import-analysis"',
    'http.html:"vite:import-meta"',
    'http.html:"vite:import-glob"',
    'http.html:"vite:import-glob-eager"',
    'http.html:"vite:import-glob-default"',
    'http.html:"vite:import-glob-all"',
    'http.html:"vite:import-glob-raw"',
    'http.html:"vite:import-glob-url"',
    'http.html:"vite:import-glob-worker"',
    'http.html:"vite:import-glob-shared"',
    'http.html:"vite:import-glob-async"',
    'http.html:"vite:import-glob-sync"',
    'http.html:"vite:import-glob-static"',
    'http.html:"vite:import-glob-dynamic"',
    'http.html:"vite:import-glob-external"',
    'http.html:"vite:import-glob-internal"'
]

def is_ip(address):
    return re.match(r"^\d{1,3}(\.\d{1,3}){3}$", address) is not None

def grab_domains():
    import math

    while True:
        try:
            total_num = int(input(f"{Fore.YELLOW}Enter the total number of sites to grab (10-1000000): {Style.RESET_ALL}"))
            if 10 <= total_num <= 1000000:
                break
            else:
                print(f"{Fore.RED}Please enter a number between 10 and 1,000,000.{Style.RESET_ALL}")
        except ValueError:
            print(f"{Fore.RED}Invalid input. Please enter a number.{Style.RESET_ALL}")

    extra_filter = input(f"{Fore.YELLOW}Enter any extra filters (e.g., hostname:.id) or press Enter to skip: {Style.RESET_ALL}").strip()

    # Define date range for splitting queries (last 3 years)
    end_date = datetime.date.today()
    start_date = end_date - datetime.timedelta(days=365*3)  # 3 years ago

    date_ranges = [(start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d"))]

    country_input = input(f"{Fore.YELLOW}Enter country codes separated by commas (e.g., US,JP,DE) or press Enter to skip: {Style.RESET_ALL}").strip()
    country_list = [c.strip().upper() for c in country_input.split(",") if c.strip()] if country_input else [None]

    if not country_list:
        country_list = [None]
        per_country_quota = total_num
    else:
        per_country_quota = total_num // len(country_list)
        remainder = total_num % len(country_list)

    try:
        for idx, country in enumerate(country_list):
            this_country_quota = per_country_quota + (1 if idx < remainder else 0) if country_list != [None] else per_country_quota
            if this_country_quota == 0:
                continue

            print(f"{Fore.LIGHTGREEN_EX}Starting search for Vite dev servers in {country if country else 'ALL'} (quota: {this_country_quota})...{Style.RESET_ALL}")

            result_dir = f"ResultGrabVite/{country if country else 'ALL'}"
            os.makedirs(result_dir, exist_ok=True)
            now_str = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
            host_output_path = os.path.join(result_dir, f"ResultHost_{now_str}.txt")
            ip_output_path = os.path.join(result_dir, f"ResultIP_{now_str}.txt")

            open(host_output_path, "w").close()
            open(ip_output_path, "w").close()

            result_set = set()

            for date_start, date_end in date_ranges:
                if len(result_set) >= this_country_quota:
                    break

                for query_base in VITE_QUERIES:
                    if len(result_set) >= this_country_quota:
                        break

                    query = query_base
                    if country:
                        query += f' country:{country}'
                    if extra_filter:
                        query += f' {extra_filter}'

                    pages_needed = min(math.ceil((this_country_quota - len(result_set)) / 100), 10000)  # 10000 pages = 1,000,000 results
                    for page in range(1, pages_needed + 1):
                        api = shodan.Shodan(SHODAN_API_KEY)
                        try:
                            results = api.search(query, page=page)
                            matches = results.get('matches', [])
                            print(f"\n{Fore.MAGENTA}Fetched page {page} with {len(matches)} matches for query: {query}{Style.RESET_ALL}")
                            for match in matches:
                                hostnames = match.get('hostnames', [])
                                ip = match.get('ip_str', None)
                                if hostnames:
                                    for hostname in hostnames:
                                        if not is_ip(hostname) and hostname not in result_set:
                                            result_set.add(hostname)
                                            print(f"{Fore.GREEN}Found hostname: {hostname}{Style.RESET_ALL}")
                                            with open(host_output_path, "a") as f:
                                                f.write(hostname + "\n")
                                elif ip and ip not in result_set:
                                    result_set.add(ip)
                                    print(f"{Fore.GREEN}Found IP: {ip}{Style.RESET_ALL}")
                                    with open(ip_output_path, "a") as f:
                                        f.write(ip + "\n")
                            if len(result_set) >= this_country_quota:
                                break
                        except Exception as e:
                            print(f"{Fore.RED}Shodan error: {e}{Style.RESET_ALL}")
                            time.sleep(2)
                        time.sleep(1)
            print(f"\n{Fore.LIGHTGREEN_EX}Search complete for {country if country else 'ALL'}. Total results collected: {len(result_set)}{Style.RESET_ALL}")
            print(f"{Fore.LIGHTGREEN_EX}Saved hostnames to {host_output_path}{Style.RESET_ALL}")
            print(f"{Fore.LIGHTGREEN_EX}Saved IPs to {ip_output_path}{Style.RESET_ALL}")

    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}Interrupted by user! Exiting...{Style.RESET_ALL}")
        sys.exit(0)

def domain_to_ip():
    filename = input(f"{Fore.YELLOW}Enter the filename containing domains (one per line): {Style.RESET_ALL}").strip()
    result_dir = "ResultDomainToIPVite"
    os.makedirs(result_dir, exist_ok=True)
    now_str = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    output_file = os.path.join(result_dir, f"DomainToIP_{now_str}.txt")
    if not os.path.isfile(filename):
        print(f"{Fore.RED}File not found: {filename}{Style.RESET_ALL}")
        return
    # Load already written IPs to avoid duplicates
    written_ips = set()
    if os.path.isfile(output_file):
        with open(output_file, "r") as out:
            for line in out:
                written_ips.add(line.strip())
    with open(filename, "r") as f, open(output_file, "a") as out:
        for line in f:
            domain = line.strip()
            if not domain:
                continue
            try:
                ip = socket.gethostbyname(domain)
                result = f"{domain} -> {ip}"
                print(f"{Fore.GREEN}{result}{Style.RESET_ALL}")
                if ip not in written_ips:
                    out.write(f"{ip}\n")
                    out.flush()
                    written_ips.add(ip)
            except Exception as e:
                print(f"{Fore.RED}Failed to resolve {domain}: {e}{Style.RESET_ALL}")
    print(f"{Fore.LIGHTGREEN_EX}Results saved to {output_file}{Style.RESET_ALL}")

def reverse_ip_lookup():
    filename = input(f"{Fore.YELLOW}Enter the filename containing IPs (one per line): {Style.RESET_ALL}").strip()
    result_dir = "ResultIPToDomainVite"
    os.makedirs(result_dir, exist_ok=True)
    now_str = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    output_file = os.path.join(result_dir, f"IPToDomain_{now_str}.txt")
    if not os.path.isfile(filename):
        print(f"{Fore.RED}File not found: {filename}{Style.RESET_ALL}")
        return
    api = shodan.Shodan(SHODAN_API_KEY)
    # Load already written domains to avoid duplicates
    written_domains = set()
    if os.path.isfile(output_file):
        with open(output_file, "r") as out:
            for line in out:
                written_domains.add(line.strip())
    with open(filename, "r") as f, open(output_file, "a") as out:
        for line in f:
            ip = line.strip()
            if not ip:
                continue
            try:
                host_info = api.host(ip)
                hostnames = set(host_info.get("hostnames", []))
                domains = set(host_info.get("domains", []))
                found = hostnames | domains
                for domain in found:
                    if domain and domain not in written_domains:
                        print(f"{Fore.GREEN}{ip} -> {domain}{Style.RESET_ALL}")  # CLI output
                        out.write(f"{domain}\n")  # TXT output
                        out.flush()
                        written_domains.add(domain)
                if not found:
                    print(f"{Fore.YELLOW}{ip} -> [No domain found]{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}Shodan error for {ip}: {e}{Style.RESET_ALL}")
            time.sleep(1)  # Respect Shodan rate limit
    print(f"{Fore.LIGHTGREEN_EX}Results saved to {output_file}{Style.RESET_ALL}")

def main():
    while True:
        print(f"{Fore.YELLOW}Choose between (1-3){Style.RESET_ALL}")
        print(f"{Fore.YELLOW}1. Grab Hostname/Domain from Shodan{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}2. Domain to IP{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}3. IP to Domain (Reverse IP){Style.RESET_ALL}")
        choice = input(f"{Fore.YELLOW}{Style.BRIGHT}Enter your choice (1, 2, or 3): {Style.RESET_ALL}")
        if choice == "1":
            grab_domains()
        elif choice == "2":
            domain_to_ip()
        elif choice == "3":
            reverse_ip_lookup()
        else:
            print(f"{Fore.RED}Invalid choice. Please enter 1, 2, or 3.{Style.RESET_ALL}")

if __name__ == "__main__":
    main()
